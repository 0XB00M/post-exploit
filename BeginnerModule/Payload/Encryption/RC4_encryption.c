#include <Windows.h>
#include <stdio.h>

typedef struct
{
	unsigned int i;
	unsigned int j;
	unsigned char s[256];

} Rc4Context;


void rc4Init(Rc4Context* context, const unsigned char* key, size_t length)
{
	unsigned int i;
	unsigned int j;
	unsigned char temp;

	// Check parameters
	if (context == NULL || key == NULL)
		return ERROR_INVALID_PARAMETER;

	// Clear context
	context->i = 0;
	context->j = 0;

	// Initialize the S array with identity permutation
	for (i = 0; i < 256; i++)
	{
		context->s[i] = i;
	}

	// S is then processed for 256 iterations
	for (i = 0, j = 0; i < 256; i++)
	{
		//Randomize the permutations using the supplied key
		j = (j + context->s[i] + key[i % length]) % 256;

		//Swap the values of S[i] and S[j]
		temp = context->s[i];
		context->s[i] = context->s[j];
		context->s[j] = temp;
	}

}


void rc4Cipher(Rc4Context* context, const unsigned char* input, unsigned char* output, size_t length) {
	unsigned char temp;

	// Restore context
	unsigned int i = context->i;
	unsigned int j = context->j;
	unsigned char* s = context->s;

	// Encryption loop
	while (length > 0)
	{
		// Adjust indices
		i = (i + 1) % 256;
		j = (j + s[i]) % 256;

		// Swap the values of S[i] and S[j]
		temp = s[i];
		s[i] = s[j];
		s[j] = temp;

		// Valid input and output?
		if (input != NULL && output != NULL)
		{
			//XOR the input data with the RC4 stream
			*output = *input ^ s[(s[i] + s[j]) % 256];

			//Increment data pointers
			input++;
			output++;
		}

		// Remaining bytes to process
		length--;
	}

	// Save context
	context->i = i;
	context->j = j;
}



#define new_line() printf("\n\n");

int main(void) {

	//Struct initialize
	Rc4Context ctx = { 0 };
	// Key used for encryption
	unsigned char* key = "boom123";
	SIZE_T key_length = strlen(key);
	/*void rc4Init(Rc4Context* context, const unsigned char* key, size_t length)*/
	rc4Init(&ctx, key, strlen(key));


	/*
	Encryption
	plaintext - The payload to be encrypted
	ciphertext - A buffer that is used to store the outputted encrypted data
	*/
	const unsigned char payload[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	};
	unsigned char ciphertext[sizeof(payload)];
	/*rc4Cipher(Rc4Context * context, const unsigned char* input, unsigned char* output, size_t length)*/
	rc4Cipher(&ctx, &payload, &ciphertext, sizeof(payload));
	for (int i = 0; i < sizeof(payload); i++) {
		printf("%hx", payload[i]);
	}
	new_line();
	for (int i = 0; i < sizeof(payload); i++) {
		printf("%hx", ciphertext[i]);
	}
	new_line();


	/* Decryption */
	Rc4Context ctx2 = { 0 };
	rc4Init(&ctx2, key, key_length);
	// ciphertext - Encrypted payload to be decrypted
	// plaintext - A buffer that is used to store the outputted plaintext data
	unsigned char plaintext[sizeof(payload)];
	rc4Cipher(&ctx2, ciphertext, &plaintext, sizeof(payload));
	for (int i = 0; i < sizeof(plaintext); i++) {
		printf("%hx", plaintext[i]);
	}

	return 0;
}
